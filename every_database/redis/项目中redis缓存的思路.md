首先，缓存的对象有三种：

1：数据库中单条的的数据（以表名跟id作为key永久保存到redis），在有更新的地方都要更新缓存（不适用于需要经常更新的数据）；

2：对于一些不分页，不需要实时（需要多表查询）的列表，我们可以将列表结果缓存到redis中，设定一定缓存时间作为该数据的存活时间。用获取该列表的方法名作为key，列表结果为value；这种情况只试用于不经常更新且不需要实时的情况下。

3：不需要实时的，需要分页的列表：可以把分页的结果列表放到一个map（key为分页标识，value为分页结果）中，然后将该map存到redis的list中（用该方法名为key）。然后给该list设置一个缓存存活时间（用expire）。这样通过方法名lrange出来就能获取存有分页列表的数据，遍历该list，通过遍历list中map的key判断该分页数据是否在缓存内，是则返回，不存在则rpush进去。这种做法能解决比如1-5页的数据已经重新加载，而6-10页的数据依然是缓存的数据而导致脏数据的情况。

本人走过的一些弯路：

1.对于数据缓存不是所有东西都缓存到redis就是好的，而是要针对一些改动不大或者访问率大的数据进行缓存来减少关系型数据库的压力。

2.不要试图在拦截器或者过滤器中判断是否有缓存的存在，因为每个请求（不管该请求对应的方法是否做了缓存）它都会去redis中请求数据并判断，这样会浪费一定的内存资源跟响应时间。所以应该针对需要缓存的方法进行判断。

3.一个方法中使用多个get或者set的方法，我们需要尽可能的减少去jedispool中获取jedis对象，所以在一个方法中应该只获取一次jedis对象，在方法结束的时候把该对象return还给连接池，这样才能做到尽可能的高效。

4.在设置连接池中参数的时候要考虑到自身系统需求，不然会经常出现连接池中无可用对象获取，spring时不时发起连接请求到redis等不必要的错误和资源浪费。

 